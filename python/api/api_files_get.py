import base64
import os
from python.helpers.api import ApiHandler, Request, Response
from python.helpers import files
from python.helpers.print_style import PrintStyle
import json


# Sensitive file patterns that should never be accessed via API
BLOCKED_PATTERNS = [
    '.env', 'secrets.env', '.git', '.ssh', 'id_rsa', 'id_ed25519',
    'credentials', 'password', '.pem', '.key', 'shadow', 'passwd'
]


def is_path_safe(path: str, base_dir: str) -> bool:
    """
    Validate that a path is safe to access.
    Returns True if path is within base_dir and not a sensitive file.
    """
    try:
        # Resolve the real path (handles symlinks and ..)
        real_path = os.path.realpath(path)
        real_base = os.path.realpath(base_dir)

        # Check if resolved path is within the base directory
        if not real_path.startswith(real_base + os.sep) and real_path != real_base:
            return False

        # Check for sensitive file patterns
        path_lower = real_path.lower()
        for pattern in BLOCKED_PATTERNS:
            if pattern in path_lower:
                return False

        return True
    except (OSError, ValueError):
        return False


class ApiFilesGet(ApiHandler):
    @classmethod
    def requires_auth(cls) -> bool:
        return False

    @classmethod
    def requires_csrf(cls) -> bool:
        return False

    @classmethod
    def requires_api_key(cls) -> bool:
        return True

    @classmethod
    def get_methods(cls) -> list[str]:
        return ["POST"]

    async def process(self, input: dict, request: Request) -> dict | Response:
        try:
            # Get paths from input
            paths = input.get("paths", [])

            if not paths:
                return Response(
                    '{"error": "paths array is required"}',
                    status=400,
                    mimetype="application/json"
                )

            if not isinstance(paths, list):
                return Response(
                    '{"error": "paths must be an array"}',
                    status=400,
                    mimetype="application/json"
                )

            result = {}
            base_dir = files.get_base_dir()

            for path in paths:
                try:
                    # Convert internal paths to external paths
                    if path.startswith("/a0/tmp/uploads/"):
                        # Internal path - convert to external
                        filename = os.path.basename(path.replace("/a0/tmp/uploads/", ""))
                        external_path = files.get_abs_path("tmp/uploads", filename)
                    elif path.startswith("/a0/"):
                        # Other internal Agent Zero paths
                        relative_path = path.replace("/a0/", "")
                        external_path = files.get_abs_path(relative_path)
                    else:
                        # Only allow paths within the base directory for security
                        external_path = os.path.normpath(path)
                        if not os.path.isabs(external_path):
                            external_path = files.get_abs_path(external_path)

                    filename = os.path.basename(external_path)

                    # Security: Validate path is within allowed directory
                    if not is_path_safe(external_path, base_dir):
                        PrintStyle.warning(f"Access denied - path outside allowed directory or blocked: {path}")
                        continue

                    # Check if file exists
                    if not os.path.exists(external_path):
                        PrintStyle.warning(f"File not found: {path}")
                        continue

                    # Don't allow reading directories
                    if os.path.isdir(external_path):
                        PrintStyle.warning(f"Cannot read directory: {path}")
                        continue

                    # Read and encode file
                    with open(external_path, "rb") as f:
                        file_content = f.read()
                        base64_content = base64.b64encode(file_content).decode('utf-8')
                        result[filename] = base64_content

                    PrintStyle().print(f"Retrieved file: {filename} ({len(file_content)} bytes)")

                except Exception as e:
                    PrintStyle.error(f"Failed to read file {path}: {str(e)}")
                    continue

            # Log the retrieval
            PrintStyle(
                background_color="#2ECC71", font_color="white", bold=True, padding=True
            ).print(f"API Files retrieved: {len(result)} files")

            return result

        except Exception as e:
            PrintStyle.error(f"API files get error: {str(e)}")
            return Response(
                json.dumps({"error": f"Internal server error: {str(e)}"}),
                status=500,
                mimetype="application/json"
            )
